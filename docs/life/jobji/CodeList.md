
这里主要记录leetcode刷过的题。刷题列表主要来源于[NeetCode](https://neetcode.io/)。

## 0. 刷题表纯享

这里直接放置所有刷过的题列表。

[**Arrays & Hashing:**](#Arrays_Hashing)

- [x] [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/), Easy
- [x] [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/), Easy
- [x] [1. Two Sum](https://leetcode.com/problems/two-sum/), Easy
- [x] [628. Maximum Product of Three Numbers](https://leetcode.com/problems/maximum-product-of-three-numbers/), Easy
- [x] [884. Uncommon Words from Two Sentences](https://leetcode.com/problems/uncommon-words-from-two-sentences/), Easy
- [x] [697. Degree of an Array](https://leetcode.com/problems/degree-of-an-array/), Easy
- [x] [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/), Medium
- [x] [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/), Medium
- [x] [238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/), Medium
- [x] [36. Valid Sudoku](https://leetcode.com/problems/valid-sudoku/), Medium
- [ ] [encode-and-decode-strings](https://leetcode.com/problems/encode-and-decode-strings/), Medium, 需要会员
- [x] [128. Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/), Medium
- [ ] [31. Next Permutation](https://leetcode.com/problems/next-permutation/), Medium
- [x] [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/), Medium

<br>

[**Two Pointers:**](#Two_Pointers)
- [x] [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/), Easy
- [x] [167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/), Medium
- [x] [15. 3Sum](https://leetcode.com/problems/3sum/), Medium
- [x] [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/), Medium
- [x] [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/), Hard

<br>

[**Sliding Window:**](#Sliding_Window)
- [x] [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/), Easy
- [x] [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/), Medium
- [x] [424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/), Medium
- [x] [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/), Medium
- [ ] [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/), Hard
- [x] [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/), Hard

<br>

[**Stack:**](#Stack)

- [x] [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/), Easy
- [x] [155. Min Stack](https://leetcode.com/problems/min-stack/), Medium
- [x] [150. Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/), Medium
- [x] [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/), Medium
- [x] [739. Daily Temperatures](https://leetcode.com/problems/daily-temperatures/), Medium
- [x] [853. Car Fleet](https://leetcode.com/problems/car-fleet/), Medium
- [ ] [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/), Hard

<br>

[**Binary Search:**](#Binary_Search)

- [x] [704. Binary Search](https://leetcode.com/problems/binary-search/), Easy
- [x] [74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/), Medium
- [x] [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/), Medium
- [x] [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/), Medium
- [x] [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/), Medium
- [x] [981. Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store/), Medium
- [x] [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/), Medium
- [x] [1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/), Medium
- [ ] [4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/), Hard

<br>

[**Linked List:**](#Linked_List)

- [x] [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/), Easy
- [x] [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/), Easy
- [x] [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/), Easy
- [x] [143. Reorder List](https://leetcode.com/problems/reorder-list/), Medium
- [x] [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/), Medium
- [x] [138. Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/), Medium
- [x] [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/), Medium
- [x] [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/), Medium
- [x] [146. LRU Cache](https://leetcode.com/problems/lru-cache/), Medium
- [ ] [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/), Hard
- [ ] [25. Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/), Hard

<br>

[**Trees:**](#Trees)

- [x] [226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/), Easy
- [x] [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/), Easy
- [x] [111. Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/), Easy
- [x] [543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/), Easy
- [x] [110. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/), Easy
- [x] [100. Same Tree](https://leetcode.com/problems/same-tree/), Easy
- [x] [572. Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/), Easy
- [x] [235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/), Easy
- [x] [94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/), Easy
- [ ] [102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/), Medium
- [ ] [199. Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/), Medium
- [ ] [1448. Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/), Medium
- [ ] [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/), Medium
- [ ] [230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/), Medium
- [ ] [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/), Medium
- [ ] [124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/), Hard
- [ ] [297. Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/), Hard

<br>

[**Tries:**](#Tries)

- [ ] [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/), Medium
- [ ] [211. Design Add and Search Words Data Structure](https://leetcode.com/problems/design-add-and-search-words-data-structure/), Medium
- [ ] [212. Word Search II](https://leetcode.com/problems/word-search-ii/), Hard

<br>

[**Heap / Priority Queue:**](#HeapOrPriorityQueue)

- [x] [703. Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/), Easy
- [x] [1046. Last Stone Weight](https://leetcode.com/problems/last-stone-weight/), Easy
- [x] [973. K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/), Medium
- [ ] [215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/), Medium
- [ ] [621. Task Scheduler](https://leetcode.com/problems/task-scheduler/), Medium
- [ ] [355. Design Twitter](https://leetcode.com/problems/design-twitter/), Medium
- [x] [1642. Furthest Building You Can Reach](https://leetcode.com/problems/furthest-building-you-can-reach/), Medium
- [ ] [295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/), Hard

<br>

[**Backtracking:**](#Backtracking)

- [ ] [78. Subsets](https://leetcode.com/problems/subsets/), Medium
- [ ] [39. Combination Sum](https://leetcode.com/problems/combination-sum/), Medium
- [ ] [46. Permutations](https://leetcode.com/problems/permutations/), Medium
- [ ] [90. Subsets II](https://leetcode.com/problems/subsets-ii/), Medium
- [ ] [40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/), Medium
- [ ] [79. Word Search](https://leetcode.com/problems/word-search/), Medium
- [ ] [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/), Medium
- [ ] [17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/), Medium
- [ ] [51. N-Queens](https://leetcode.com/problems/n-queens/), Hard

<br>

[**1-D Dynamic Programming:**](#1D_Dynamic_Programming)

https://leetcode.com/study-plan/dynamic-programming/

https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns

- [x] [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/), Easy
- [ ] [746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/), Easy
- [x] [198. House Robber](https://leetcode.com/problems/house-robber/), Medium
- [ ] [213. House Robber II](https://leetcode.com/problems/house-robber-ii/), Medium
- [ ] [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/), Medium
- [ ] [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/), Medium
- [ ] [91. Decode Ways](https://leetcode.com/problems/decode-ways/), Medium
- [ ] [322. Coin Change](https://leetcode.com/problems/coin-change/), Medium
- [ ] [152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/), Medium
- [ ] [139. Word Break](https://leetcode.com/problems/word-break/), Medium
- [ ] [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/), Medium
- [ ] [416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/), Medium
- [x] [120. Triangle](https://leetcode.com/problems/triangle/), Medium

<br>

[**2-D Dynamic Programming:**](#2D_Dynamic_Programming)

- [x] [62. Unique Paths](https://leetcode.com/problems/unique-paths/), Medium
- [x] [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/), Medium
- [ ] [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/), Medium
- [ ] [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/), Medium
- [ ] [518. Coin Change 2](https://leetcode.com/problems/coin-change-2/), Medium
- [ ] [494. Target Sum](https://leetcode.com/problems/target-sum/), Medium
- [ ] [97. Interleaving String](https://leetcode.com/problems/interleaving-string/), Medium
- [ ] [329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/), Hard
- [ ] [115. Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/), Hard
- [ ] [72. Edit Distance](https://leetcode.com/problems/edit-distance/), Hard
- [ ] [312. Burst Balloons](https://leetcode.com/problems/burst-balloons/), Hard
- [ ] [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), Hard

<br>

[**Greedy:**](#Greedy)

- [ ] [455. Assign Cookies](https://leetcode.com/problems/assign-cookies/), Easy
- [ ] [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/), Medium
- [ ] [55. Jump Game](https://leetcode.com/problems/jump-game/), Medium
- [ ] [45. Jump Game II](https://leetcode.com/problems/jump-game-ii/), Medium
- [ ] [134. Gas Station](https://leetcode.com/problems/gas-station/), Medium
- [ ] [846. Hand of Straights](https://leetcode.com/problems/hand-of-straights/), Medium
- [ ] [97. Interleaving String](https://leetcode.com/problems/interleaving-string/), Medium
- [ ] [1899. Merge Triplets to Form Target Triplet](https://leetcode.com/problems/merge-triplets-to-form-target-triplet/), Medium
- [ ] [763. Partition Labels](https://leetcode.com/problems/partition-labels/), Medium
- [ ] [678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/), Medium
- [x] [881. Boats to Save People](https://leetcode.com/problems/boats-to-save-people/), Medium

<br>

[**Intervals:**](#Intervals)

- [ ] [57. Insert Interval](https://leetcode.com/problems/insert-interval/), Medium
- [ ] [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/), Medium
- [ ] [435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/), Medium
- [ ] [Meeting Rooms](https://leetcode.com/problems/meeting-rooms/), Easy, 需要会员
- [ ] [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/), Medium, 需要会员
- [ ] [1851. Minimum Interval to Include Each Query](https://leetcode.com/problems/minimum-interval-to-include-each-query/), Hard

<br>

[**Math & Geometry:**](#Math_Geometry)

- [x] [66. Plus One](https://leetcode.com/problems/plus-one/), Easy
- [x] [202. Happy Number](https://leetcode.com/problems/happy-number/), Easy
- [x] [13. Roman to Integer](https://leetcode.com/problems/roman-to-integer/), Easy
- [x] [48. Rotate Image](https://leetcode.com/problems/rotate-image/), Medium
- [ ] [54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/), Medium
- [x] [73. Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/), Medium
- [x] [50. Pow(x, n)](https://leetcode.com/problems/powx-n/), Medium
- [ ] [43. Multiply Strings](https://leetcode.com/problems/multiply-strings/), Medium
- [ ] [2013. Detect Squares](https://leetcode.com/problems/detect-squares/), Medium
- [x] [593. Valid Square](https://leetcode.com/problems/valid-square/), Medium
- [x] [204. Count Primes](https://leetcode.com/problems/count-primes/), Medium
- [x] [1492. The kth Factor of n](https://leetcode.com/problems/the-kth-factor-of-n/), Medium




## 1. 题解

这里放置所有刷过题的题解。

[这里](https://github.com/kobe24o/LeetCode/blob/master/LeetCode%E8%A7%A3%E9%A2%98%E6%B1%87%E6%80%BB%E7%9B%AE%E5%BD%95.md)提供了LeetCode上许多题目的中文题解。

### Arrays & Hashing :id=Arrays_Hashing

[217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)

用`set()`，对比前后两个的长度；

直接用`collections.Counter`；

用哈希表

<br>

[242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)

判断两个字符串是否只是排列顺序不同

最直接，使用`Counter`计数比较，时间空间复杂度都是 $\mathcal{O}(s+t)$；

由于两个字符串的本质区别是排列组合的顺序不同，因此，如果我们都对他们进行排序，两个字符串应该是相同的。这样某些排序算法可以把空间复杂度降低到 $\mathcal{O}(1)$，但是时间复杂度上升到 $\mathcal{O}(n \log n)$

<br>

[1. Two Sum](https://leetcode.com/problems/two-sum/)

1. 暴力循环/蛮力算法（brutal force），是$C_n^2, \mathcal O(n^2)$ 

2. 先排序，然后用two-pointers，最左+最右 如果小于target，就左边指针右移，如果大于target，就右边指针左移

   排序是 $n \log n$，指针移动是 $n$，所以最后是 $\mathcal O(n\log n)$ 

   ```python
   ls = [2, 6, 4, 7]
   ls.sort() #直接改变列表；指定参数reverse=True，则排序为降序，默认是升序
   
   for i in enumerate(ls):
       print(i)
   #(0, 2)
   #(1, 6)
   #(2, 4)
   #(3, 7)
   ```

   

3. hash table $\mathcal O(n)$：所有的插入和查询操作都是 $\mathcal O(1)$

   遍历元素，如果它的补元素不在字典里，则加进去；如果补元素在字典里，则该补元素的位置和它的位置即为输出

   ```python
   # nums = [2, 4, 6, 7]
   # target = 9
   
   d = {}
           
   for i, num in enumerate(nums):
       if num not in d:
           d[target - num] = i
       else:
           return [d[num], i]
   ```

<br>

[628. Maximum Product of Three Numbers](https://leetcode.com/problems/maximum-product-of-three-numbers/)

先排序，那么乘积最大的就是最大的三个正数，或者最大的正数和最小的两个负数。应是 $\mathcal O(n \log n)$ 

但实际上，我们就是要找最大的三个正数和最小的两个负数，这样一个操作是可以通过一次遍历就得到的。通过一次遍历，找出最大的三个数，和最小的两个数。也就是 $\mathcal O(n)$ 

<br>

[884. Uncommon Words from Two Sentences](https://leetcode.com/problems/uncommon-words-from-two-sentences/)

两个字符串拼一起，找出来只出现过一次的单词；

可以直接用`collections.Counter`

```python
from collections import Counter

s = "This is an example an is"
count = Counter(s.split(' ')) # Counter({'is': 2, 'an': 2, 'This': 1, 'example': 1})
ls = [word for word, c in count.items() if c == 1] # ['This', 'example']
```

字典常用操作：`d.get(key)`， `for key, value in d.items()`
如果字典中不存在`key`，可以通过类似`d.get(key, 0)`的方式让它返回`0`

<br>

[697. Degree of an Array](https://leetcode.com/problems/degree-of-an-array/)

```python
from collections import defaultdict

c = defaultdict(int)
c[1] += 1 # defaultdict(int)对任意键的初始值设为0
```

<br>

[49. Group Anagrams](https://leetcode.com/problems/group-anagrams/)

直接对每个字符串排序，对该值计数，但如果涉及排序的话，时间复杂度（$\mathcal O(m n \log n)$）会高（但神奇的是leetcode上更快）；

依然使用`Counter`的思路，需要注意的是*Python里的字典不能使用字典和列表作为键，但是可以使用tuple作为键。tuple是不可更改的列表，也是有序的*。因此，我们用一个列表，每个位置分别记录对应字符串中出现各字母的次数；然后将该列表转换为tuple来做为键。时间复杂度为 $\mathcal{O}(mn)$，其中 $m$ 是列表长度，$n$ 是列表中字符串平均长度

<br>

[347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

用最大堆不是最优解，复杂度 $\mathcal O(n \log n)$

利用Bucket Sort的思想，把 value-count 反过来，变成 count-value 的映射模式，把count直接按照bucket存进去，然后每个count下挂一个列表，包含对应计数次数的数字，时间空间复杂度都是 $\mathcal O(n)$

<br>

[238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)

因为不让用除法，因此可以记录从前到后连乘，从后到前连乘，即 prefix postfix 序列，这样时间和空间复杂度都是 $\mathcal O (n)$；

其实就是prefix连乘序列和postfix连乘序列错位相乘，因此这个过程可以只用一个序列完成，即不需要extra space；但不是最快的

![](fig/IMG_424EFF231707-1.jpeg ':size=40%')

<br>

[36. Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)

暴力检查，把每个格子扫一遍，分别check三个条件
```python
'1'.isdecimal()

from itertools import product
for i in product([1, 2], [1, 2]):
    print(i)
```

<br>

[128. Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/)

如果排序的话，就很好做，但是排序是 $\mathcal O(n \log n)$；

利用`set`的查询为 $\mathcal O (1)$

<br>

[31. Next Permutation](https://leetcode.com/problems/next-permutation/)

这个是真题

<br>

[560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)

构建序列 $S_i = a_1 + \cdots+a_i$，问题转化为找出所有的 $(i, j)$ 使得 $S_j - S_i = k$，用two-sum思路解子问题
注意，这两个过程可以同时进行

对于数组 $[1, 2, 3, 4]$，它的prefix sum（前缀和）数组为 $[1, 3, 6, 10]$。


### Two Pointers :id=Two_Pointers


[125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)

全转小写，然后直接判断；但是用了extra memory
```python
s = '1a'
s.lower()
s = s.join(['1', 'n'])
for i in s:
    print(i.isalpha(), i.isnumeric(), i.isalnum())
```

用two pointers，没必要将整个序列反过来
```python
def AlphaNum(s):
    return (ord('A') <= ord(s) <= ord('Z') or
            ord('a') <= ord(s) <= ord('z') or
            ord('0') <= ord(s) <= ord('9'))
```

<br>

[167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)


two sum的进阶版

利用数列的有序性，使用two pointers

时间 $\mathcal{O}(n)$，空间 $\mathcal O(1)$

<br>

[15. 3Sum](https://leetcode.com/problems/3sum/)


有了前面的基础，这道题就是two sum和two sum ii的结合。

$a+b+c=0$ 等价于 $a+b = -c$，所以先排序，然后遍历负的部分，转换为 $a+b$ 的two sum问题（同时注意不能加入重复答案、要搜到左右指针重合才停止）

排序是 $\mathcal{O}(n \log n)$，$n$ 个two sum是 $\mathcal{O}(n^2)$，最后应是 $\mathcal O(n^2)$ 

<br>

[11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)

Brute force $\mathcal O(n^2)$

two pointers结合贪心，每次向里移动更小高度的指针，$\mathcal O(n)$

<br>

[42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)

给定箱体，则很容易计算出箱体内能放多少水，难点在如何确定箱体
左向右滑动得到 $\max L$，右向左滑动得到 $\max R$，计算 $\min(\max L, \max R)$，这样TC和SC均为 $\mathcal O(n)$

用two pointers，因为每个bar能存储的水量由该点左侧最高值和右侧最高值这两个值中的最小值决定，并且 $\max L, \max R$ 是（不严格）单调增，因此我们每次只滑动当前最大值中较小的那个，可以确保滑动到的bar的“高”就是这个最小值。这样SC降为 $\mathcal O(1)$

### Sliding Window :id=Sliding_Window

[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

遍历一遍，记录每一步当前价格最小值，动态记录对当前最低价格而言的最高盈利。应是 $\mathcal O(n)$ 
```python
float('-inf') #最小值
```

<br>

[3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

用sliding window，需要用到判断新元素是否在之前的子列里，因此可以考虑用`set`，因为查询在不在里面只需要constant time
同时结合two pointers (同向)，滑动一遍只需要 $\mathcal O(n)$

<br>

[424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)

从左到右扫+two pointers，如果当前子列中，长度$-$最多重复次数$\leq k$，则当前子列即可以被完全替换；如果不满足，就左移指针，直到满足
循环直到右指针到头

<br>


[567. Permutation in String](https://leetcode.com/problems/permutation-in-string/)

sliding window，每次对比滑动得到的字符串和原始字符串
注意每次滑动只变化两个元素，即窗口开始元素和窗口结束元素
处理可以类似前面Anagram
```python
ord('a')
chr()
```

<br>

[76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)



<br>

[239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

![img](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/dq7aw.jpg)

Monotonically Decreasing Queue 单调递减队列，是 Deque 双端队列的一种；
```python
from collections import deque

q = deque()
q.append(1)
q.append(2)
q.pop()
q.popleft()
```
deque的`popleft()`与`pop()`都是 $\mathcal O(1)$ 的操作，因此这道题是使用deque的经典题，用后只需要扫一遍就能得出答案，TC和SC为 $\mathcal O(n)$

```python
from collections import deque
class Solution:
    def maxSlidingWindow(self, nums, k):
        # using deque, TC, SC O(n)
        res = [0] * (len(nums) - k + 1)
        l = r = 0
        q = deque() # monotonically decreasing; composed of indices
        
        while r < len(nums):
            # compared with nums[r], pop smaller one from the deque
            # make sure the leftmost in the biggest
            while q and nums[q[-1]] < nums[r]:
                q.pop()
            q.append(r) # add r
            
            # make sure the leftmost is in-bound
            if l > q[0]:
                q.popleft() # remove out-of-bound index
                
            # starts adding result
            if r + 1 >= k:
                res[l] = nums[q[0]]
                l += 1
            r += 1
        
        return res
```

同理，可以写出单调递增队列：

```python
def minSlidingWindow(nums, k):
    dq = deque() # increasing deque, composed of indices
    ans = [0] * (len(nums) - k + 1)
    l = r = 0
    while r < len(nums):
        # make sure the right most is smaller or equal to current number
        while dq and nums[r] < nums[dq[-1]]:
            dq.pop()
        # add current number('s index)
        dq.append(r)
        # make sure the left most is in-bound
        while dq and dq[0] < l:
            dq.popleft()
        # start adding result
        if r + 1 >= k:
            ans[l] = nums[dq[0]]
            l += 1
        r += 1

    return ans

print(minSlidingWindow([4, 3, -2, 9, -4, 2, 7, 6], 3))
```

<br>

### Stack :id=Stack

[20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

栈的基础运用

```python
stack = [1, 2, 3]
stack.pop()
```

<br>

[155. Min Stack](https://leetcode.com/problems/min-stack/)

另建一个列表，记录每加一个新元素进去的时候当前最小是多少

<br>

[150. Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)

对栈的基础运用

```python
int(6 / -132) # 向0取整
```

<br>

[22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)

用dp，首先是 $() + dp[n-1]$，然后是 $(dp[1]) + dp[n-2]$，一直到 $(dp[n-1])$ ；

我们只能加入 $n$ 个 '(' 以及 $n$ 个 ')'，因此，我们从零开始构造答案时，每一步我们都可以选择加入一个 '(' 或者一个 ')'，这样就能构造一个二叉树，二叉树最下面的一层就是我们想要的结果。这样我们可以用backtrack去做，
也可以用DFS（+ stack）去做

三种解法，DFS最快

<br>

[739. Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)

最直接的想法是用同向two pointers，TC最差 $\mathcal O(n^2)$，不可取；

用Monotonic (decreasing) Stack，（非严格）单调（递减）栈。即，设计一个单调递减的栈，每次存元素时，保持栈里元素的单调递减；一直pop到栈为空或者有一个元素大于当前元素为止，那么那些被弹出元素对应的原始位置，结果就是原始位置和当前元素位置的差。TC和SC都是 $\mathcal O(n)$ 

<br>

[853. Car Fleet](https://leetcode.com/problems/car-fleet/)

Python排序并获取对应下标：
```python
x = [5, 6, 3, 8]
b = sorted(enumerate(x), key=lambda x: x[1]) 
print(b) # [(2, 3), (0, 5), (1, 6), (3, 8)]
```

比如 target = 10，position = [0, 2, 4]，speed = [2, 3, 1]，这里的position已经排过序，首先计算他们各自到终点需要的时间：T = [5, 2.6, 6]；然后从右往左看，2.6 < 6，说明car2车能赶上car3，这个2.6就被6”吸收“掉了，因为car2赶上car3后会以car3的速度走；再看，5 < 6，说明car1也能赶上car3，因此fleet = 3 - 1 - 1 = 1。TC $\mathcal O(n \log n)$，空间稍微用多点

上面描述的方法，后面操作部分可以动态用stack做。这样空间消耗少很多

<br>

[84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)

<br>

### Binary Search :id=Binary_Search

[704. Binary Search](https://leetcode.com/problems/binary-search/)

最基础的二分查找，TC $\mathcal O(\log n)$，找到目标值就退出：

```python
def search(nums, target):
    l, r = 0, len(nums) - 1
    while l <= r:
        m = (l + r) // 2
        # to avoid overflow:
        # m = l + (r - l) // 2
        if nums[m] == target:
            return m
        elif nums[m] < target:
            l = m + 1
        else:
            r = m - 1
    else:
    	return -1
```

<br>

[74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)

二维的二分查找，先确定行数，再确定列数，TC $\mathcal O(\log m + \log n)$，$m$ 行 $n$ 列

<br>

[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)

$k$ 最小可能是1，最大可能是数列中最大的数，因此对这个范围做二分搜索

<br>

[33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)

直观思路是先找出pivot，再分开做二分查找，这种做法应该可行，实际因为找pivot的方法错误，报错过多；

直接用二分。如果中间值大于等于左指针，说明我们在左半部分。此时如果目标值大于中间值，或者目标值小于左指针，说明目标值应该在右侧，应移动左指针；否则移动右指针。
如果中间值小于右指针，说明我们在右半部分。如果目标值小于中间值，或者目标值大于右指针，说明目标值应该在左侧，应移动右指针；否则移动左指针。

<br>

[153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

这题直接就是找出pivot，那就整
首先排除edge case：只有一个数的情况，只有两个数的情况；数列超过三个数字时，第一个数字最小和最后一个数字最小的情况
这样，我们就保证最小值/pivot一定在中间部分，此时直接做二分搜索。如果中间值满足小于前后两个值，则该中间值就是最小值；如果该中间值大于整个数列的第一个数字，说明我们在数列的左半部分，则右指针左移；否则左指针右移

也可以直接二分。首先判断，如果右指针大于左指针，说明此时的数列已经是单调增了，那么当前最小就是左指针；如果中间值大于等于左指针，说明在左半部分，右指针左移；最后一种情况，左指针右移。每次要对比当前中间值与上次相比是否是最小的，因此这种方法没有上面那种快

<br>

[981. Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store/)

如果在存储的时候能保持有序，则在查询的时候就可以用二分：
```python
ls = []
ls.insert(0, 'asd') # 在第0处插入'asd'
```

然而，这道题在存的时候就已经自动保持有序了（最好和面试官check一下），因此查询的时候可以直接二分

<br>

[34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

本题即为找到目标值后继续搜，直到两个指针相遇；
左边界二分搜索和右边界二分搜索

<br>

[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)

这道题跟[google的OA](https://leetcode.com/discuss/interview-question/348510/Google-or-OA-2019-or-Maximum-Area-Serving-Cake)一样，用generalized binary search。首先定义函数，来确定当前的值是否满足情况；然后确定下界和上界，做二分搜索

<br>

[4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

<br>

### Linked List :id=Linked_List

[206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)

通过设置prev curr指针，可以做到TC $\mathcal O(n)$，SC $\mathcal O(1)$；

用recursion，将空间复杂度升到 $\mathcal O(n)$

<br>

[21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)

考察linked list的基础运用，在最左侧加dummy node

<br>

[141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

Python里的class也是可以hash的，因此直接做法就是把所有访问过的节点全都放到`set()`里；

Floyd's Tortoise and Hare算法：设置一个slow pointer和一个fast pointer，如果有loop，那么fast pointer会和slow pointer相遇。假设它俩之间的gap是 $m$，那么只需要 $m$ 步两者就能相遇，因此这个算法的TC依然是 $\mathcal O(n)$，SC降为 $\mathcal O(1)$

<br>

[143. Reorder List](https://leetcode.com/problems/reorder-list/)

直接做法，把每个节点都存起来，这样是 $\mathcal O(n)$ 的额外空间；

或者，将整个链（通过slow fast pointer）分为两部分，将后半段链顺序反向，再将两端链merge起来，这样额外空间 $\mathcal O(1)$

<br>

[19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

直接把每个节点都存起来，可做；

还是类似用slow fast pointer的思想，设置两个指针，这两个指针之间的距离即为 $n$，直到右指针移到空（需要在最左加dummy），不需要额外空间

<br>

[138. Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/)

直接做法：two passes，先第一遍建立出所有新节点，并用哈希表将原节点与新节点一一对应起来，这样TC $\mathcal O(n)$，额外空间 $\mathcal O(n)$；

额外空间可以降为常数，具体参考下图：

<img src="https://raw.githubusercontent.com/hot13399/leetcode-graphic-answer/master/138.%20Copy%20List%20with%20Random%20Pointer.jpg" alt="alt text" style="zoom:75%;" />
类似DNA复制，先把所有节点都复制一个节点并紧贴原节点加入原链，再连接，再分离，这样空间复杂度 $\mathcal O(1)$

<br>

[2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)

注意edge case，感觉这题没什么意思，一定程度提高一点对链表操作的熟练度

<br>

[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)

注意题目的约束条件：列表内的每个数字取值范围 $[1, n]$，列表长度为 $n+1$，且列表内有且仅有一个重复数字，即说明列表一定类似 $[1, 2, 3, 1]$ 这种形式。
这是一个链表问题。构建一个从0开始的链表，0指向位置0处存储的1，再指向位置1处存储的2，再指向位置2处存储的3，再指向位置3处存储的1，这里注意到我们的链表已经出现了一个环。用Floyd算法，设置一个slow pointer和一个fast pointer，记录他们第一次相遇的地方，假设进入环前的距离为 $p$，相遇的地方离环的入口距离为 $x$，环的长度为 $c$，则根据慢指针走过的所有距离应是快指针的一半这一关系，能够得到 $2(p + c - x) = p + (c-x) + c$，化简得到 $p = x$。上面的情况是简单情况，总之，再从起点放置一个慢指针，与相遇位置指针同速运动，再相遇时对应数字即为结果。

<br>

[146. LRU Cache](https://leetcode.com/problems/lru-cache/)

the least recently used key: 在所有存储的键值对中，如果有最近被调用`get()`或者用`put()`修改值的，就代表“有用”；对于最先存进去的键，或者最没有被调用过的键，即为容量满时要去除的键。
这题的关键点在于，维持一个有序的序列，如果用普通的array，它的插删操作都是 $\mathcal O(n)$，达不到要求的 $\mathcal O(1)$；因此，答案是用双链表 double linked list，因为双链表中每个节点记录了前一节点和后一节点。对于查找要求的 $\mathcal O(1)$，我们知道hash map可以做到。
因此，这道题把这两个数据结构结合，构建一个key-value的哈希表，其中value是对应双链表中的节点。先建两个dummy node，即head和tail。

<br>

[23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)

<br>

[25. Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)



### Trees :id=Trees

[226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)

recursion，左子树为右子树的翻转，右子树为左子树的翻转

BFS + deque

DFS + stack
DFS可以选择只加入非空的节点，也可以选择把空节点也一起加到栈里

<br>

[104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

recursion

BFS + deque，每往下一层就深度加一

Iterative DFS + stack，把每个节点对应的深度也存到栈里
二叉树的遍历：preorder 先序，根左右；inorder 中序，左根右；postorder 后序，左右根

<br>

[111. Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/)

recursion

BFS + deque，一层一层看，只要当前层有节点没有左右子节点，即可返回

DFS + stack，同时存储每个节点对应的深度，如果该节点是叶节点（没有左右子节点），则更新输出

<br>

[543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)

这道题并不简单。
关键点在于看出，如果最大路径要经过根节点的话，那么即为左子树的最大深度加上右子树的最大深度。因此，用recursive DFS，新建一个返回最大深度的函数，同时每次递归求深度的时候都更新最终结果

<br>

[110. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)

二叉平衡树：
Balanced tree: a binary tree in which the left and right subtrees of **every** node differ in height by no more than 1.

用recursive DFS，左子树和右子树都要是平衡树，且两者深度相差不超过1

上述方法可以优化，直接从下向上检测，同时直接返回height，即不分开计算height，这样每个节点只访问一次

<br>

[100. Same Tree](https://leetcode.com/problems/same-tree/)

recursion

也可以用BFS或DFS做，即维持一个deque或stack，里面元素为p和q的节点对

<br>

[572. Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)

接上题，用recursion，判断当前树和给定子树是否相同，然后判断当前树的左右子树是否于给定子树相同，有任意相同结果即返回True，因此逻辑关系要用or

神奇操作，通过preorder traversal，将两颗树都转换为字符串，然后查看是否子树字符串包含在给定树内

<br>

[235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

Lowest Common Ancestor (LCA) 最低公共祖先

从根节点开始，因为根节点是所有节点的公共祖先。
首先，二叉搜索树满足，左<根<右
从上到下，如果出现有一个节点已经作了根节点，那么即代表这个节点就是最低公共祖先；如果出现分叉，即一个节点的数值小于当前根节点，另一个节点的数值大于当前根节点，即代表当前这个节点是最低公共祖先。
每层只会搜索一个节点，因此TC $\mathcal O(\log n)$，SC $\mathcal O(1)$

<br>

[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)

![](https://assets.leetcode.com/users/andvary/image_1556551007.png)

<br>

[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)

<br>

[199. Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/)

<br>

[1448. Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)

<br>

[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)

二叉搜索树：
a valid binary search tree (BST) is defined as follows:

- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than the node's key.
- Both the left and right subtrees must also be binary search trees.

同时查看左子树和右子树是否有效，对左子树而言，根节点的值就是左子树的上界

<br>

[230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)

<br>

[105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

<br>

[124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)

<br>

[297. Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)



### Tries :id=Tries

[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)

<br>

[211. Design Add and Search Words Data Structure](https://leetcode.com/problems/design-add-and-search-words-data-structure/)

<br>

[212. Word Search II](https://leetcode.com/problems/word-search-ii/)



### Heap / Priority Queue :id=HeapOrPriorityQueue

[703. Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/)

如果维护一个有序数组，排序是 $\mathcal O(n \log n)$，每次插入都是 $\mathcal O(n)$，成本较高；

使用Python的`heapq`模块：
```python
import heapq
# 默认是最小堆，通过加负值转化为最大堆
heapq.heappush(heap, item)

heapq.heapify(list) # TC: O(n)；这个函数不会返回，用法类似ls.sort()

heapq.heappop(heap) 

heapq.nlargest(n,heap) 

heapq.nsmallest(n,heap) 
```
用min heap with size $k$，这样最小堆的顶部就是倒数第 $k$ 大的，因为我们只会加数字进去而不会删，因此不在堆里的数字（更小的数字）永远不会再被用到。同时`heapify`转化堆是 $\mathcal O(n)$，堆的增删都是 $\mathcal O(\log n)$ 

<br>

[1046. Last Stone Weight](https://leetcode.com/problems/last-stone-weight/)

直接用最大堆模拟

<br>

[973. K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/)

直接用`sorted()`函数，排序 $\mathcal O(n \log n)$

类似前面的思想，维持一个size为 $k$ 的最大堆，每次都把最大值弹出，这样最终堆里留下的就是 $k$ 个最小距离对应的点，TC $\mathcal O(n \log k)$，SC $\mathcal O(k)$ 

quick select，用来找出前/第 $k$ 大/小的元素，平均只需要 $\mathcal O(n)$ 的时间

<br>

[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)

直接用`heapq`能过；



<br>

[621. Task Scheduler](https://leetcode.com/problems/task-scheduler/)

<br>

[355. Design Twitter](https://leetcode.com/problems/design-twitter/)

<br>

[1642. Furthest Building You Can Reach](https://leetcode.com/problems/furthest-building-you-can-reach/), Medium

ladders可以爬上任意高度的楼，因此我们要把ladders留给最高的几个gap，排序较低里的gap留给bricks。考虑动态维护一个最小堆，如果堆里的gap总数大于ladders，则pop出最小的gap，用bricks去补

<br>

[295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)



### Backtracking :id=Backtracking

[78. Subsets](https://leetcode.com/problems/subsets/)

<br>

[39. Combination Sum](https://leetcode.com/problems/combination-sum/)

<br>

[46. Permutations](https://leetcode.com/problems/permutations/)

<br>

[90. Subsets II](https://leetcode.com/problems/subsets-ii/)

<br>

[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)

<br>

[79. Word Search](https://leetcode.com/problems/word-search/)

<br>

[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)

<br>

[17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

<br>

[51. N-Queens](https://leetcode.com/problems/n-queens/)



### 1-D Dynamic Programming :id=1D_Dynamic_Programming

[70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)

Fibonacci Number

<br>

[746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)

<br>

[198. House Robber](https://leetcode.com/problems/house-robber/)
$$
f(k) = \max\left( f(k-1), f(k-2)+\text{nums}(k) \right)
$$
<br>

[213. House Robber II](https://leetcode.com/problems/house-robber-ii/)

<br>

[5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

<br>

[647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)

<br>

[91. Decode Ways](https://leetcode.com/problems/decode-ways/)

<br>

[322. Coin Change](https://leetcode.com/problems/coin-change/)

<br>

[152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)

<br>

[139. Word Break](https://leetcode.com/problems/word-break/)

<br>

[300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)

<br>

[416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)

<br>

[120. Triangle](https://leetcode.com/problems/triangle/)

从下往上，可以直接利用给定数组覆盖，能节省空间



### 2-D Dynamic Programming :id=2D_Dynamic_Programming

[62. Unique Paths](https://leetcode.com/problems/unique-paths/)

dp打表

<br>

[64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)

类似上题的dp打表

<br>

[1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)

<br>

[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

<br>

[518. Coin Change 2](https://leetcode.com/problems/coin-change-2/)

<br>

[494. Target Sum](https://leetcode.com/problems/target-sum/)

<br>

[97. Interleaving String](https://leetcode.com/problems/interleaving-string/)

<br>

[329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/)

<br>

[115. Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/)

<br>

[72. Edit Distance](https://leetcode.com/problems/edit-distance/)

<br>

[312. Burst Balloons](https://leetcode.com/problems/burst-balloons/)

<br>

[10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)



### Greedy :id=Greedy

[455. Assign Cookies](https://leetcode.com/problems/assign-cookies/)

<br>

[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

<br>

[55. Jump Game](https://leetcode.com/problems/jump-game/)

<br>

[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)

<br>

[134. Gas Station](https://leetcode.com/problems/gas-station/)

<br>

[846. Hand of Straights](https://leetcode.com/problems/hand-of-straights/)

<br>

[1899. Merge Triplets to Form Target Triplet](https://leetcode.com/problems/merge-triplets-to-form-target-triplet/)

<br>

[763. Partition Labels](https://leetcode.com/problems/partition-labels/)

<br>

[678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/)

<br>

[881. Boats to Save People](https://leetcode.com/problems/boats-to-save-people/)

先排序，如果当前的最沉带不动最轻，那么最沉单独走；不然，则两两配对

### Intervals :id=Intervals

[57. Insert Interval](https://leetcode.com/problems/insert-interval/)



[56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)



[435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)



[Meeting Rooms](https://leetcode.com/problems/meeting-rooms/)



[Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)



[1851. Minimum Interval to Include Each Query](https://leetcode.com/problems/minimum-interval-to-include-each-query/)



### Math & Geometry :id=Math_Geometry

[66. Plus One](https://leetcode.com/problems/plus-one/)

过

<br>

[202. Happy Number](https://leetcode.com/problems/happy-number/)

过

<br>

[13. Roman to Integer](https://leetcode.com/problems/roman-to-integer/)

如果一个更小的罗马数字出现在了前面，则说明是要减掉的，而不是加上。如，$\text{IV} = 5 - 1, \text{VI} = 5+1$。

<br>

[48. Rotate Image](https://leetcode.com/problems/rotate-image/)

显示写出旋转图片的坐标变换，过

<br>

[54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)

<br>

[73. Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)

自然的做法是，把有零的行和列记录下来，SC $\mathcal O(m+n)$；

或者，直接把记录合并到矩阵第一行和第一列，SC缩小到 $\mathcal O(1)$

<br>

[50. Pow(x, n)](https://leetcode.com/problems/powx-n/)

devide and conquer + recursion, $\mathcal O(\log n)$

<br>

[43. Multiply Strings](https://leetcode.com/problems/multiply-strings/)

<br>

[2013. Detect Squares](https://leetcode.com/problems/detect-squares/)

<br>

[593. Valid Square](https://leetcode.com/problems/valid-square/)

计算4个点两两之间6条边，边长不应该有0，且unique的边长只应有2个
```python
import itertools

for i in itertools.combinations([1, 2, 3, 4], 2):
    print(i)
#(1, 2)
#(1, 3)
#(1, 4)
#(2, 3)
#(2, 4)
#(3, 4)
```

<br>

[204. Count Primes](https://leetcode.com/problems/count-primes/)

用Sieve of Eratosthenes，厄拉多塞筛法。如果 $n \leq N$，且 $n$ 是合数，则 $n$ 必能被一个不大于 $\sqrt{N}$ 的素数所整除。因此，从 $2$ 开始向上搜，把所有 $2$ 的倍数全划掉，一直搜到 $\sqrt{N}$。

<br>

[1492. The kth Factor of n](https://leetcode.com/problems/the-kth-factor-of-n/)

首先，brutal force；

Half brutal force，只遍历小于1/2的；

根号 brutal force，把所有小于等于根号的pair全加到集合中



## 2. 面经（非leetcode题目）

[PowerSum](https://leetcode.com/discuss/interview-question/516442/Swiggy-or-OA-2020-or-Is-Possible-or-Minimum-start-value-or-Power-sum/457422)

先把所有可能的平方数找出来，然后看范围内所有数字是否可以由这些数的平方数构成

```python
import math



def countPowerNumbers(l, r):
    # Write your code here
    # first identify every possible a^p, b^q
    dp = [0 for i in range(r+1)]
    dp[0] = 1
    dp[1] = 1

    for i in range(2, int(math.sqrt(r))+1):
        j = 2
        temp = i**j
        while temp <= r:
            dp[temp] = 1
            j += 1
            temp = i**j

    res = 0
    for i in range(l, r+1):
        for j in range(0, i+1):
            if dp[j] and dp[i-j]:
                res += 1
                #print(i)
                break

    return res



left = 10
right = 50
print(countPowerNumbers(left, right))



def countPowerNumbers(l, r):
    # first identify every possible a^p, b^q
    SET = set([0])
    if r >= 1:
        SET.add(1)
    for num in range(2, int(math.sqrt(r))+1):
        start_pow = 2
        temp = num**start_pow
        while temp <= r:
            SET.add(temp)
            start_pow += 1
            temp = num**start_pow
    
    res = 0
    ls = list(SET)
    for i in range(l, r+1):
        for j in ls:
            if i-j in SET:
                res += 1
                #print(i)
                break
                
    return res



print(countPowerNumbers(left, right))
```

<br>

D.E.Shaw Online Assessment Question, [Bob Navigates a Maze](https://leetcode.com/discuss/interview-question/708638/sap-labs-oa-bob-navigates-a-maze)

这题偏难

<br>

Approximate Matching

![image-20221111172115463](C:\Users\xiaot\AppData\Roaming\Typora\typora-user-images\image-20221111172115463.png)

![image-20221111172149145](C:\Users\xiaot\AppData\Roaming\Typora\typora-user-images\image-20221111172149145.png)

![image-20221111172200408](C:\Users\xiaot\AppData\Roaming\Typora\typora-user-images\image-20221111172200408.png)



<br>

Profit Analysis

![image-20221110200205163](C:\Users\xiaot\AppData\Roaming\Typora\typora-user-images\image-20221110200205163.png)

![image-20221110200247656](C:\Users\xiaot\AppData\Roaming\Typora\typora-user-images\image-20221110200247656.png)

![image-20221110200257587](C:\Users\xiaot\AppData\Roaming\Typora\typora-user-images\image-20221110200257587.png)

```python
from collections import deque
def getMaxProfit(pnl, k):
    # Write your code here
    # compute prefix sum
    S = pnl.copy()
    for i in range(len(pnl)-1):
        S[i+1] += S[i]
    res = max(S[:k])
    # compute sliding window minimum (of prefix sum)
    def minSlidingWindow(nums, k):
        dq = deque() # increasing deque, composed of indices
        ans = [0] * len(nums)
        for i in range(len(nums)):
            # make sure the right most is smaller or equal to current number
            while dq and nums[i] < nums[dq[-1]]:
                dq.pop()
            # add current number('s index)
            dq.append(i)
            # make sure the left most is in-bound
            while dq and dq[0] < max(0, i-k+1):
                dq.popleft()
            # add result
            ans[i] = nums[dq[0]]
        return ans
    SlidingMin_S = minSlidingWindow(S, k)
    for i in range(1, len(pnl)):
        res = max(res, S[i] - SlidingMin_S[i-1])

    return max(res, 0)

print(getMaxProfit([4, 3, -2, 9, -4, 2, 7], 6)) # 15
print(getMaxProfit([5, -7, 8, -6, 4, 1, -9, 5], 5)) # 8
```

<br>

Circular Printer

![image-20221112095743427](C:\Users\xiaot\AppData\Roaming\Typora\typora-user-images\image-20221112095743427.png)

![image-20221112095802944](C:\Users\xiaot\AppData\Roaming\Typora\typora-user-images\image-20221112095802944.png)

这题简单。

```python
def getTime(s):
    # Write your code here
    curr = 'A'
    res = 0
    for letter in s:
        temp = abs(ord(letter) - ord(curr))
        res += min(temp, 26-temp)
        curr = letter
    return res

print(getTime('AZGB')) # 13
```

<br>

String Modification

![image-20221114225031714](C:\Users\xiaot\AppData\Roaming\Typora\typora-user-images\image-20221114225031714.png)

![image-20221114225050047](C:\Users\xiaot\AppData\Roaming\Typora\typora-user-images\image-20221114225050047.png)

不知道什么原理，但能过所有case：

```python
def getMinMoves(s):
    # Write your code here
    n = len(s) #that's the size of s
    inf = float('inf') # create a number which is very huge

    dp_good = [[inf for __ in range(26)] for _ in range(n)] # list of goods
    dp_bad = [[0 for __ in range(26)] for _ in range(n)] # list of bads

    # base case
    for c in range(26):
        dp_bad[0][c] = abs(ord(s[0]) - ord("a") - c)
    # general case
    for i in range(1, n):
        prev_best = inf
        for c in range(26):
            prev_best = min(prev_best, dp_good[i-1][c]) # find the min
        for c in range(26):
            dp_good[i][c] = min(dp_good[i-1][c], dp_bad[i-1][c]) # find the min
            dp_good[i][c] += abs(ord(s[i]) - ord("a") - c) # add the calculation
            dp_bad[i][c] = prev_best + abs(ord(s[i]) - ord("a") - c)
    ans = inf
    for i in range(26):
        ans = min(ans, dp_good[n - 1][i])
    return ans
```

